#LyX 1.5.6 created this file. For more info see http://www.lyx.org/
\lyxformat 276
\begin_document
\begin_header
\textclass article
\language spanish
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\paperfontsize default
\spacing single
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 0
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language swedish
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Section
Relevamiento de tecnologías
\begin_inset LatexCommand label
name "sec:Relevamiento-de-tecnologías"

\end_inset


\end_layout

\begin_layout Standard
El relevamiento de paquetes de software que permitan el desarrollo y la
 ejecución de programas paralelos y distribuidos fue una actividad muy important
e dentro del proyecto pues esta nos definiria la siguientes actividades
 a realizar.
 El relevamiento se enfocó en sistemas de administración de cluster, sistemas
 de despacho de trabajos y sistemas de monitoreo de clusters.
 Algunas caracteristicas que se tuvieron en cuenta en el relevamiento del
 software base fueron la performance, interfaz amigable para usuarios del
 cluster, interfaz de administración del cluster e infromación del cluster
 y ejecución de trabajos brindada por la misma y que fueran de código abierto.
 
\end_layout

\begin_layout Standard
Previamente al relevamiento se establecieron el sistema operativo que sería
 alguna distribución de Linux, por ejemplo Fedora, y las bibliotecas PVM
 y MPI para el desarrollo para programas paralelos y distribuidos .
\end_layout

\begin_layout Standard
A continuación se detallaran las aplicaciones que fueran relevadas y sus
 caracteristicas.
\end_layout

\begin_layout Subsection
SSI:OpenMosix
\begin_inset Foot
status open

\begin_layout Standard
Moshe Bar, fundador y director de proyecto de openMosix (uno de los proyectos
 SSI mas influyentes al momento del relevamiento de tecnologías), anuncio
 el 15 de julio del 2007 el cierre del proyecto y que se congelará tanto
 su desarrollo como el soporte brindado a partir del 1 de marzo del 2008.
\end_layout

\end_inset

, OpenSSI y Kerrighed
\end_layout

\begin_layout Standard
A diferencia de un cluster tradicional en un cluster SSI todas las computadoras
 vinculadas dependen de un sistema operativo idéntico en común.
 Un middleware SSI oculta la naturaleza heterogénea y distribuida de los
 recursos, y los presenta a los usuarios y a las aplicaciones como un recurso
 computacional unificado y sencillo.
 Una de las metas que mas diferencia un SSI de un cluster o un grid tradicional
 es su completa transparencia en la gestión de recursos.
 Es debido a esta completa transparencia que es posible migrar procesos
 de un nodo a otro.
 Tampoco es necesario programación adicional para beneficiarse del paralelismo,
 de esta manera no es necesario re-escribir programas utilizando bibliotecas
 como PVM (Parallel Virtual Machine) o MPI (Message Passing Interface).
\end_layout

\begin_layout Standard
A pesar de las ventajas presentadas por los SSI a nivel de manejo de recursos,
 no creemos que se ajusten a los requerimientos planteados principalmente
 debido a que el cluster ya se encuentra en funcionamiento siguiendo un
 paradigma estilo beowulf mas clásico.
 Quizás sea interesante construir un pequeño cluster SSI e investigar más
 a fondo este tipo de tecnologías de manera de poder comparar ambas soluciones.
\end_layout

\begin_layout Subsection
Condor
\end_layout

\begin_layout Subsubsection
Características generales
\end_layout

\begin_layout Standard
Condor es un proyecto open-source de la universidad de Wisconsin específicamente
 diseñado para High-Throughput Computing (HTC).
 Si bien Condor puede utilizarse con fines de High-Performance Computing
 (HPC) existen importantes diferencias entre HPC y HTC.
 Fundamentalmente los trabajos ejecutados en un entorno HPC se caracterizan
 por necesitar resolver un problema en el menor tiempo posible, en cambio
 en un entorno HTC ya es sabido que no es posible resolver los problemas
 en tiempos pequeños, estamos hablando de meses o años en lugar de horas
 o días.
 Como consecuencia en HPC el poder computacional de un cluster normalmente
 es medido en operaciones de punto flotante por segundo (FLOPS), en cambio
 la comunidad HTC se interesa mas en la cantidad de trabajos que posible
 completar en un largo periodo de tiempo, no interesa que tan rápido puede
 terminarse un trabajo individual.
 Debido a este perfil de tipo HTC, Condor se enfoca principalmente en la
 robustez y la confiabilidad brindando funcionalidades como: CPU harvesting,
 migración de procesos, tolerancia a fallas y process checkpoint.
\end_layout

\begin_layout Standard
Paradójicamente si bien se trata de un proyecto open-source su código fuente
 no se distribuye libremente.
 Para obtener el código fuente de Condor es necesario enviar un correo electróni
co explicando la razón por la que se quiere obtener el código fuente y cada
 petición es analizada puntualmente.
\end_layout

\begin_layout Subsubsection
Bibliotecas para programación paralela
\end_layout

\begin_layout Standard
Condor se encuentra diseñado principalmente para la ejecución de trabajos
 seriales.
 Si bien provee soporte limitado para las bibliotecas PVM y MPI para procesamien
to paralelo su desempeño en esta área se encuentra por debajo de otros DRM's
 como TORQUE o SGE.
\end_layout

\begin_layout Subsubsection
Interfaz de programación
\end_layout

\begin_layout Standard
Condor brinda una interfaz de programación propietaria, y no soporta el
 estándar DRMAA.
\end_layout

\begin_layout Subsubsection
Resumen
\end_layout

\begin_layout Standard
Condor no parece ser el software ideal para el proyecto.
 Si bien puede adaptarse a los requerimientos planteados y brinda funcionalidade
s interesantes (p.ej.
 migración de procesos, cpu harvesting, etc.) existen áreas criticas en las
 que se encuentra claramente en desventaja con respecto a otros productos.
 El limitado soporte que brinda Condor a las bibliotecas PVM y MPI resulta
 ser un problema crítico y determinante para que fuera descartado en el
 sistema planteado en el proyecto.
\end_layout

\begin_layout Subsection
Sun grid engine 6.1
\end_layout

\begin_layout Standard
Sun Grid Engine es un software para administración de recursos distribuidos
 que dinámicamente asocia requerimientos de hardware y software de los usuarios
 con los recursos disponibles en la red (generalmente heterogéneos) de acuerdo
 a políticas predefinidas.
\end_layout

\begin_layout Standard
Sun Grid Engine actúa como el sistema nervioso central de un cluster de
 computadoras conectadas.
 A partir de algunos demonios, el Sun Grid Master supervisa todos los recursos
 de la red para permitir control completo y alcanzar la utilización óptima
 de los mismos.
\end_layout

\begin_layout Standard
Sun Grid Engine fue desarrollado como realce de Codine de Genias GmbH y
 Grisdware Inc., de acuerdo a requerimientos de varios clientes tales como
 el laboratorio de investigación del ejército de Aberdeen y BMW.
 Con Sun Grid Engine, el uso medio de los recursos aumentó de menos del
 50% a más del 90% en ambos ambientes.
\end_layout

\begin_layout Standard
Sun Grid Engine reúne el poder de cálculo disponible en granjas de computadoras
 dedicadas, servidores conectados y computadoras de escritorio, y las presenta
 desde un único punto de acceso para el usuario que necesita ciclos de cómputo.
 Esto se logra distribuyendo la carga de trabajo entre los sistemas disponibles,
 aumentando la productividad de máquinas y del uso de licencias, mientras
 se maximiza el número de trabajos que pueden ser completados.
\end_layout

\begin_layout Standard
Los requerimientos de hardware son mínimos (100 MB de memoria disponible
 y 500MB de disco) y soporta la mayoría de los sistemas operativos populares.
 Soporta las plataformas SPARC Ultra III, SPARC Ultra IV, AMD64, x86 y Mac.
\end_layout

\begin_layout Standard
Permite control de usuarios, limitando tanto el número máximo de trabajos
 por usuario, grupo y proyecto, como recursos tales como colas, hosts, memoria
 y licencias de software.
\end_layout

\begin_layout Standard
Los recursos requeridos por cada trabajo se pueden indicar mediante expresiones
 lógicas (por ejemplo, un usuario puede requerir que un trabajo corra en
 un host que cumpla la condición 
\begin_inset Quotes eld
\end_inset

Solaris o Linux pero no Linux en IA64
\begin_inset Quotes erd
\end_inset

).
\end_layout

\begin_layout Standard
Distributed Resource Management Application API (DRMAA) es un conjunto de
 APIs estándar desarrollado por Global Grid Forum para application builders,
 portal builders e ISV's.
 La versión 6.1 soporta los últimos C y Java bindings de DRMAA 1.0.
 Adicionalmente, es provisto de compatibilidad hacia atrás para: DRMAA 0.5
 Java binding y DRMAA 0.95 C binding.
\end_layout

\begin_layout Standard
Guarda la información referida a la cuenta de cada trabajo en una base de
 datos relacional (soportando Oracle, MySQL y PostgreSQL).
\end_layout

\begin_layout Standard
Maneja aplicaciones paralelas (MPI o PVM habilitados) a través de una interfase
 dedicada.
 
\end_layout

\begin_layout Standard
Permite la distribución de recursos a equipos o departamentos, por ejemplo
 proporcionalmente a su contribución económica.
 
\end_layout

\begin_layout Standard
El código muestra una complejidad alta, además el sistema es integrado,
 no muestra facilidades a la hora de dividirlo en subsistemas.
 Estas características hacen que en algunos aspectos se vea como un sistema
 cerrado, que no permite adaptaciones en caso de realidades no abarcadas
 por el mismo.
\end_layout

\begin_layout Subsubsection
Resumen
\end_layout

\begin_layout Standard
Sun Grid Engine 6.1 provee la mayoría de las funcionalidades requeridas para
 el proyecto.
 Por otro lado, tiene como desventaja el ser un único gran paquete indivisible,
 lo cual hace muy difícil cualquier adaptación o modificación de su funcionamien
to.
 
\end_layout

\begin_layout Standard
Si nos basamos en la historia reciente del producto, en una versión anterior
 se encontró un problema de seguridad (un salto en las restricciones) y
 quienes lo estaban utilizando en ese momento descartaron la idea de buscar
 el problema y solucionarlo, limitándose solamente a esperar que los creadores
 de la herramienta lo corrigieran.
 
\end_layout

\begin_layout Standard
Esto se debe a que la herramienta cuenta con un código muy complejo y difícil
 de modificar, lo que lo coloca como una opción poco viable para ser utilizada
 dentro del proyecto propuesto.
\end_layout

\begin_layout Subsection
OpenPBS
\end_layout

\begin_layout Standard
OpenPBS se trata de la versión original y de código abierto de PBS (Portable
 Batch System) desarrollada para la NASA a principios de los 90's.
 Actualmente es ofrecida por Altair Grid Technologies, aunque no se encuentra
 en desarrollo y la empresa no brinda ningún tipo de soporte sobre el software.
 Altair ha apostado a una versión comercial del producto llamada PBS Pro,
 y en lo que a Altair respecta OpenPBS es simplemente una forma de comenzar
 a utilizar PBS con el objetivo de comprar PBS Pro.
\end_layout

\begin_layout Standard
TORQUE (ver página 
\begin_inset LatexCommand pageref
reference "sub:TORQUE"

\end_inset

) es un sucesor de OpenPBS
\end_layout

\begin_layout Subsubsection
Características generales
\end_layout

\begin_layout Standard
PBS ofrece apoyo para programar y ejecutar trabajos que requieren el acceso
 interactivo de los usuarios a la entrada y salida del trabajo durante el
 tiempo de ejecución.
 Esto es a menudo necesario para ejecutar debuggers u otros programas que
 requieren información como parte de un trabajo que debe tener previsto
 el acceso a hardware.
\end_layout

\begin_layout Standard
PBS se prové la ejecución de dos scripts administrativos suministrados con
 cada trabajo llamados prologo y epilogo.
 El prólogo se ejecuta inmediatamente antes de que se ejecute el trabajo,
 el epílogo se ejecuta de inmediatamente después.
 Ambos scrpts se ejecutan con privilegios de root y pueden utilizarse para
 colocaruan bandera o establecer parte de la entorno para el trabajo, como
 la creación de directorios temporales o realizar una limpieza de los puestos
 de trabajo.
\end_layout

\begin_layout Subsection
TORQUE
\begin_inset LatexCommand label
name "sub:TORQUE"

\end_inset


\end_layout

\begin_layout Standard
TORQUE (Terascale Open-source Resource and QUEue manager) se trata de un
 'fork' open-source de la versión 2.3.12 de OpenPBS mantenido y desarrollado
 por Cluster Resources.
 
\end_layout

\begin_layout Standard
Incorpora muchas mejoras con respecto al proyecto PBS original provistas
 por NCSA (National Center of Supercomputing Applications), OSC (Ohio Supercompu
ter Center), Sandia, PNNL (Pacific Northwest National Laboratory), y otros
 centros HPC junto con las mejoras desarrolladas por Cluster Resources.
\end_layout

\begin_layout Subsubsection
Características generales
\end_layout

\begin_layout Standard
En TORQUE los trabajos son manejados de la misma manera que lo hace OpenPBS.
 Se cuenta con un conjunto de colas de trabajos que definen propiedades
 generales para los trabajos que contienen (p.ej.
 recursos disponibles, etc.) y al ingresar un trabajo al sistema, este debe
 especificar características especificas de si mismo que ayuden al sistema
 a planificar la ejecución del mismo (p.ej.
 nodos a utilizar, memoria máxima a utilizar, etc.).
 Con esta información (los datos de la cola a la que pertenece el trabajo
 y los datos específicos del trabajo en cuestión) el scheduler decide el
 momento en que un trabajo comienza a ejecutarse y con que recursos cuenta
 en cada instante.
\end_layout

\begin_layout Standard
TORQUE cuenta con una interfaz de usuario de línea de comando (CLI) como
 principal manera de interactuar con el sistema, también cuenta con una
 interfaz gráfica para X-Windows y una biblioteca para desarrollo en C aunque
 es posible utilizar bibliotecas desarrolladas por terceros para otros lenguajes
 (p.ej.
 Perl o Python).
\end_layout

\begin_layout Standard
Existen tres tipos de nodos en un sistema TORQUE:
\end_layout

\begin_layout Paragraph
Nodo Maestro.
\end_layout

\begin_layout Standard
Es necesario que exista un nodo maestro en el sistema.
 Aunque dependiendo del sistema este nodo maestro puede encontrarse dedicado
 únicamente a este rol o compartir otros roles.
\end_layout

\begin_layout Paragraph
Nodos Interactivos.
\end_layout

\begin_layout Standard
Los nodos interactivos proveen un punto de entrada al sistema para los usuarios.
 Es en estos nodos en que los usuarios pueden ingresar tareas al sistema
 y monitorear su progreso.
 Estos nodos deben tener comandos como qsub y qhold disponibles.
\end_layout

\begin_layout Paragraph
Nodos de cómputo.
\end_layout

\begin_layout Standard
Estos son los responsables de la ejecución de los trabajos encolados en
 el sistema.
 Son los encargados de iniciar, detener y manejar los procesos de cómputo
 en el sistema operativo del nodo en cuestión.
\end_layout

\begin_layout Subsubsection
Bibliotecas para programación paralela
\end_layout

\begin_layout Paragraph
MPI (Message Passing Interface).
\end_layout

\begin_layout Standard
El soporte para bibliotecas tipo MPI se encuentra integrado en TORQUE.
 El sistema puede ejecutar varias implementaciones de MPI: MPICH, MPICH2,
 OpenMPI, etc.
 Los recursos utilizados por procesos paralelos son correctamente registrados
 y se reporta su uso en el log del PBS.
\end_layout

\begin_layout Paragraph
PVM (Parallel Virtual Machine)
\end_layout

\begin_layout Standard
Una de las principales desventajas de TORQUE es la dificultad que plantea
 el uso de la biblioteca PVM.
 A diferencia de MPI, el soporte para PVM no se encuentra integrado al sistema
 por lo que debe manejarse cuidadosamente.
\end_layout

\begin_layout Subsubsection
Interfaz de programación
\end_layout

\begin_layout Standard
TORQUE soporta el estándar Distributed Resource Management Application API
 (DRMAA) al igual que la mayoría de los manejadores de recursos.
\end_layout

\begin_layout Subsubsection
Maui
\end_layout

\begin_layout Standard
TORQUE contiene la lógica necesaria para llevar a cabo la planificación
 de trabajos, pero se trata de una lógica muy simple que no resulta adecuada
 para un ambiente de producción.
 Básicamente el planificador que se encuentra incorporado a TORQUE maneja
 los trabajos como una cola FIFO (First-In First-Out).
 Para mejorar esto se utiliza Maui, una aplicación especializada en la planifica
ción de trabajos.
\end_layout

\begin_layout Standard
Maui se enfoca en la planificación de trabajos y deja la problemática de
 iniciar los trabajos y la interacción con los usuarios a los manejadores
 de recursos (DRM por sus siglas en inglés) como OpenPBS, TORQUE, SGE, etc.
\end_layout

\begin_layout Paragraph
Requerimientos de hardware.
\end_layout

\begin_layout Standard
Maui requiere de muy pocos recursos de hardware para su funcionamiento.
 En clusters de hasta 10 teraflops basta con entre 20 a 50 MB de RAM.
\end_layout

\begin_layout Paragraph
Plataformas soportadas.
\end_layout

\begin_layout Standard
Maui soporta los siguientes sistemas operativos: Linux, AIX, OSF/Tru-64,
 Solaris, HP-UX, IRIX, FreeBSD, y otras plataformas UNIX.
 Y los siguientes DRM: TORQUE, OpenPBS, PBSPro, Sun Grid Engine (SGE), LoadLevel
er, LSF, BProc/Scyld, Scalable System Software (SSSRM) y SLURM.
\end_layout

\begin_layout Paragraph
Características generales.
\end_layout

\begin_layout Standard
El algoritmo de planificación de Maui soporta fairness, preemption, backfill,
 etc.
 y tiene una interfaz para la interacción con un allocation management externo.
 Un allocation manager (también conocido como allocation bank o cpu bank)
 funciona como un banco en el cual la moneda son los recursos del sistema
 (p.ej.
 procesadores, memoria, etc.) autorizando a los trabajos cierta cantidad
 de recursos.
\end_layout

\begin_layout Subparagraph
Backfill.
\end_layout

\begin_layout Standard
Backfill es un acercamiento en la planificación que permite ejecutar algunos
 trabajos 'desordenadamente' siempre y cuando estos no retrasen los trabajos
 de prioridad superior de la cola.
 Para determinar si un trabajo será retrasado, cada trabajo debe proveer
 una estimación de cuánto tiempo necesitará para su ejecución.
 Esta estimación, conocida como límite wallclock, es una valoración del
 tiempo desde el comienzo del trabajo hasta su final.
 Es a menudo sabio sobrestimar levemente este límite porque el planificador
 se puede configurar para matar a los trabajos que exceden sus límites del
 wallclock.
 Sin embargo, la sobrestimación demasiado grande del tiempo del wallclock
 de un trabajo evitará que el planificador pueda optimizar correctamente
 la cola de trabajo.
 Cuanto más exacto el límite del wallclock, mayor será la posibilidad de
 que Maui encuentre agujeros en la planificación para comenzar a ejecutar
 su trabajo con mayor anticipación.
 
\end_layout

\begin_layout Subparagraph
Gerenciamiento de asignación.
\end_layout

\begin_layout Standard
Maui posee interfaces para sistemas de gerenciamiento de asignación tales
 como Gold de PNNL.
 Estos sistemas permiten que a cada usuario le sea asignada una porción
 de los recursos totales de cálculo disponibles en el sistema.
 Estos sistemas trabajan asociando a cada usuario a unas o más cuentas.
 Cuando se envía un trabajo, el usuario especifica a que cuenta se debe
 cargar los recursos consumidos por el trabajo.
\end_layout

\begin_layout Subparagraph
Reservas anticipadas.
\end_layout

\begin_layout Standard
Las reservas anticipadas permiten que un sitio disponga ciertos recursos
 a un lado para el uso específico de ciertas aplicaciones durante cierto
 tiempo.
 El acceso a una reserva dada es controlado por un Access Control List (ACL)
 que determina quién puede utilizar los recursos reservados.
 Es importante observar que mientras que un ACL permite que trabajos particulare
s utilicen recursos reservados, no fuerzan al trabajo a utilizar estos recursos.
 Maui procurará utilizar la mejor combinación posible de recursos disponibles
 sean éstos reservados o no.
 Maui puede ser configurado para que ciertos trabajos sean restringidos
 y que funcionen utilizando solamente recursos reservados, aplicando restriccion
es a nivel de trabajo o especificando ciertas restricciones especiales de
 QoS.
 
\end_layout

\begin_layout Subparagraph
Quality of Service (QoS).
\end_layout

\begin_layout Standard
Las funciones de QoS permiten otorgar ciertos privilegios especiales a usuarios,
 estos beneficios pueden incluir acceso a recursos adicionales, exclusiones
 de determinadas políticas, acceso a capacidades especiales, y mejoras en
 la priorización de trabajos.
\end_layout

\begin_layout Subparagraph
Faireshare.
\end_layout

\begin_layout Standard
Este componente permite favorecer trabajos en base al uso histórico a corto
 plazo.
 Es posible así ajustar la prioridad de un trabajo dependiendo de la utilización
 porcentual del sistema de usuarios, grupos, o QoS.
 Dada una ventana de tiempo determinado sobre la cual se evalúa la utilización
 de recursos del sistema se determina si está siendo mantenido un cierto
 balanceo o no.
\end_layout

\begin_layout Paragraph
Interfaz de programación.
\end_layout

\begin_layout Standard
Maui brinda dos interfases de programación para extender o personalizar
 el despacho de trabajos.
\end_layout

\begin_layout Subparagraph
Interfaz de extensión (Extension Interface).
\end_layout

\begin_layout Standard
Esta interfaz permite que bibliotecas externas sean 'linkeadas' al servidor
 de Maui brindando acceso a todos los datos y objetos utilizados por el
 planificador.
 Además, permite que estas bibliotecas realicen override de las principales
 funciones de Maui.
\end_layout

\begin_layout Subparagraph
Interfaz local.
\end_layout

\begin_layout Standard
Se trata de una interfaz en C enfocada exclusivamente al desarrollo de nuevos
 algoritmos de despacho.
\end_layout

\begin_layout Paragraph
Estadísticas.
\end_layout

\begin_layout Standard
Maui almacena tres diferentes clases de estadísticas:
\end_layout

\begin_layout Subparagraph
Estadísticas de tiempo real.
\end_layout

\begin_layout Standard
Estas estadísticas son mantenidas en memoria y pueden ser consultadas mediante
 comandos.
 El comando 'showstats' provee información detallada por usuario, por grupo,
 por cuenta o por nodo.
 Además en cualquier momento estas estadísticas pueden resetearse utilizando
 el comando 'resetstats'.
 
\end_layout

\begin_layout Subparagraph
Histórico.
\end_layout

\begin_layout Standard
Estas estadísticas pueden ser obtenidas para un lapso de tiempo, un tipo
 de trabajo y/o una porción de recursos utilizando el comando 'profiler'.
 Este comando utiliza la traza de información detallada de un trabajo, que
 es guardada al dar por finalizado un trabajo.
\end_layout

\begin_layout Subparagraph
Fairshare.
\end_layout

\begin_layout Standard
Este tipo de estadísticas son mantenidas sin importar si fairshare se encuentra
 habilitado.
 Al igual que las trazas de los trabajos, estas son almacenadas en archivos
 utilizando texto plano por cada ventana de fairshare.
\end_layout

\begin_layout Subsubsection
Gold
\end_layout

\begin_layout Standard
Gold es un sistema de contaduría open-source desarrollado en PNNL bajo el
 proyecto Scalable Systems Software (SSS) que lleva registro y maneja el
 uso de recursos en clusters de alto desempeño.
 Actúa de la misma forma que un banco en el que son depositados créditos
 en cuentas, estos créditos representan recursos en el sistema.
 A medida que se finalizan trabajos o que son consumidos recursos en el
 sistema se debitan créditos de sus respectivas cuentas.
\end_layout

\begin_layout Standard
Es posible realizar operaciones como depósitos, retiros, transferencias
 o reembolsos sobre las cuentas del sistema, además, provee listados de
 balances a usuarios y administradores.
\end_layout

\begin_layout Paragraph
Características generales.
\end_layout

\begin_layout Subparagraph
Reservas.
\end_layout

\begin_layout Standard
Previo al inicio de un trabajo se realiza una estimación del total de recursos
 que este consumirá, en base a esta estimación se reservan créditos en la
 cuenta correspondiente.
 Estos créditos 'reservados' se debitan una vez que el trabajo es terminado,
 de esta manera se evita que un proyecto consuma mas recursos de los que
 tiene asignados.
\end_layout

\begin_layout Subparagraph
Vencimiento de créditos.
\end_layout

\begin_layout Standard
Puede especificarse un lapso de validez a los créditos en el sistema, permitiend
o que se implemente una política de use-it-or-lose-it previniendo el uso
 exhaustivo de créditos acumulados y estableciendo ciclos a un proyecto.
\end_layout

\begin_layout Subparagraph
Interfaz Web.
\end_layout

\begin_layout Standard
Permitiendo acceso remoto a usuarios y administradores.
 
\end_layout

\begin_layout Subparagraph
Interfaz de programación.
\end_layout

\begin_layout Standard
Existen diferentes formas de integrar Gold al sistema: Perl API, Java API
 o directamente utilizando el protocolo SSSRMAP (basado en XML).
\end_layout

\begin_layout Subsubsection
Casos de estudio
\begin_inset LatexCommand label
name "sub:Torque-Casos-de-estudio"

\end_inset


\end_layout

\begin_layout Paragraph
Oregon State University, Laboratorio de física.
\end_layout

\begin_layout Standard
Actualmente cuenta con 34 computadoras Dell Optiplex GX620's con procesadores
 Intel Pentium D 830 (3.0 GHz) y 1 GB of RAM con sistema operativo SUSE GNU/Linux
 10.1 64-bit.
\end_layout

\begin_layout Standard
Estas computadoras cuentan con compiladores Intel para C, C++ y Fortran,
 la biblioteca Math Kernel Library (cluster edition).
 Para el procesamiento paralelo se utilizan las bibliotecas MPI.
 El cluster utiliza TORQUE como manejador de recursos, y desde el 4 de febrero
 del 2007 se utiliza Maui para la planificación de tareas.
 
\end_layout

\begin_layout Paragraph
University of Glasgow.
\end_layout

\begin_layout Standard
El cluster utiliza TORQUE y Maui sobre Redhat Enterprise GNU/Linux 3.
 Actualmente cuenta con 60 nodos de procesamiento disponibles, cada uno
 con procesadores duales Opteron 248 y 2GB RAM.
 Además de los componentes estándares de incluidos en la distribución (p.ej.
 compilador gcc, g++, g77, etc.) se han instalado las bibliotecas MPICH 1.2.6
 (MPI) para procesamiento paralelo.
\end_layout

\begin_layout Paragraph
University of Heidelberg.
\end_layout

\begin_layout Standard
El cluster fue instalado a principios de 2002 y consisten de 512 procesadores
 AMD Athlon MP, instalados en 256 nodos de procesamiento SMP con 2 GB de
 memoria RAM cada uno.
 Los procesadores funcionan cada uno a 1.4GHz y alcanzan un máximo teórico
 de 2.4 billones de operaciones de punto flotante por segundo (Gflops).
 El sistema total indica un máximo teórico de desempeño de mas de 1.4 Teraflops.
 Las primeras mediciones de desempeño utilizando Linpack Benchmark mostraron
 un rendimiento de 825 Gflops, ubicando el cluster en la posición 35va del
 top 500 de supercomputadoras del mundo en Junio del 2002.
\end_layout

\begin_layout Standard
Como base del cluster se utiliza un sistema Debian GNU/Linux.
 Para procesamiento paralelo se utiliza la biblioteca mpich (MPI) y como
 manejador de recursos se utiliza TORQUE.
 Por sobre TORQUE se encuentra instalado Moab, el sucesor de Maui.
 
\end_layout

\begin_layout Paragraph
Stony Brook University.
\end_layout

\begin_layout Standard
El cluster tiene 235 nodos de procesamiento dual (470 procesadores individuales).
 Cada procesador es un Dell Pentium IV Xeon de 3.4GHz con 2GB de memoria
 RAM y 40 GB de disco duro.
 Los computadores operan con Debian GNU/Linux, utilizan TORQUE y Maui para
 manejar los trabajos y la versión 1.4 de MPI para el procesamiento paralelo.
\end_layout

\begin_layout Paragraph
Dansk Center for Scientific Computing.
\end_layout

\begin_layout Standard
El cluster consta de 200 nodos Dell PowerEdge 1950 1U con dos procesadores
 Intel Woodcrest de 2,66 GHz.
 De estos 200 nodos 160 cuentan con 4 GB de RAM y 40 cuentan con 8 GB de
 RAM.
 Como sistema se utiliza openSUSE GNU/Linux 10.1 con kernel 2.6 y para la
 planificación y manejo de trabajos de utiliza TORQUE 2.1.2 y MAUI 3.2.6.
 Para el procesamiento paralelo se disponen de bibliotecas tanto de tipo
 MPI como de tipo PVM.
\end_layout

\begin_layout Subsubsection
Resumen
\end_layout

\begin_layout Standard
TORQUE junto con Maui y Gold satisfacen los requerimientos planteados para
 el proyecto.
 Su consumo de recursos del cluster es relativamente bajo, se adapta muy
 bien al manejo de clusters pequeños y posee un manejo eficiente de trabajos
 paralelos (sobre todo si estos son homogéneos).
 
\end_layout

\begin_layout Standard
Existen ciertos aspectos en los que TORQUE no se desempeña de la mejor manera.
 Si bien se encuentra integrado el soporte para bibliotecas tipo MPI, debe
 tenerse mucho cuidado al momento de ejecutar trabajos utilizando PVM.
 TORQUE presenta carencias también en sus funcionalidades de Resource Management
; p.
 ej.
 no es capaz de realizar CPU Harvesting o migración de procesos.
\end_layout

\begin_layout Standard
En cuanto al soporte por parte de la comunidad de usuarios de TORQUE y Maui,
 es muy bueno por medio de listas de correo y también se encuentra mucha
 documentación disponible en el sitio Web por medio de una Wiki (aunque
 aún se encuentra en construcción).
\end_layout

\begin_layout Subsection
Ganglia
\end_layout

\begin_layout Standard
Ganglia es un sistema de monitoreo, escalable y distribuido, para sistemas
 de alto desempeño como clusters de computadores o grids.
 Es un proyecto de código abierto y se encuentra disponible para una amplia
 cantidad de sistemas operativos: Linux, BSD, Solaris, Windows, Darwin,
 etc.
 
\end_layout

\begin_layout Standard
Ganglia utiliza tecnologías ampliamente difundidas como: XML para la representac
ión de datos, XDR para la comunicación y RRDtool para el almacenamiento
 y visualización de datos.
 El proyecto posee un amplio énfasis en consumir el mínimo overhead posible
 por nodo y brindar un máximo de concurrencia.
 Posee una implementación robusta y puede manejar clusters con hasta 2000
 nodos.
\end_layout

\begin_layout Standard
Ganglia se encuentra compuesto por tres partes:
\end_layout

\begin_layout Paragraph
GMonD
\end_layout

\begin_layout Standard
GMonD (Ganglia Monitoring Daemon) es un servicio encargado del monitoreo
 de un nodo en particular y debe estar instalado en cada una de las máquinas
 que se desee monitorear.
 Este servicio recolecta métricas del sistema en base a CPU, memoria, disco
 duro, tráfico de red y utiliza un protocolo simple vía XDR para compartir
 esta información mediante XML sobre TCP.
\end_layout

\begin_layout Paragraph
GMetaD
\end_layout

\begin_layout Standard
El meta servicio de ganglia (Ganglia Meta Daemon) es un servicio que se
 encarga de recolectar y almacenar información de otros servicios (ya sean
 servicios GMonD u otros servicios GMetaD).
 GMetaD provee un mecanismo de consultas muy simple para obtener información
 histórica acerca de grupos de máquinas.
 
\end_layout

\begin_layout Paragraph
Interfaz Web
\end_layout

\begin_layout Standard
Ganglia brinda además un front-end Web implementado en PHP para la presentación
 al usuario final de la información almacenada por el sevicio GMetaD.
 
\end_layout

\begin_layout Subsection
Apache
\end_layout

\begin_layout Standard
Apache es un servidor HTTP de código abierto para plataformas Unix (BSD,
 GNU/Linux, etc.), Windows, etc.
 Desde 1996, Apache es el servidor HTTP más utilizado.
 Alcanzó su máxima cuota de mercado en 2005 cuando llegó a ser utilizado
 por el 70% de los sitios Web en el mundo.
 Sin embargo ha sufrido un descenso en su cuota de mercado en los últimos
 años y hoy en día brinda servicio al 49% de los sitios de Internet
\begin_inset Foot
status open

\begin_layout Standard
Encuesta realizada en Junio del 2008 por Netcraft.com.
 Netcraft fue fundada en 1995 y se especializa en el análisis de mercado
 de servidores y alojamiento web incluyendo detección de servidor Web y
 sistema operativo.
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Entre las ventajas que brinda Apache podemos destacar: su enfoque altamente
 modular y un excelente soporte gracias a su gran cantidad de usuarios.
 Además, gracias a su enfoque altamente modular, Apache soporta una gran
 cantidad de lenguajes server-side como: PHP, Python, Ruby, Perl, etc.
\end_layout

\begin_layout Subsection
PHP
\end_layout

\begin_layout Standard
PHP es un acrónimo recursivo que significa PHP Hypertext Pre-processor (aunque
 inicialmente significaba Personal Home Page).
 Fue creado por Rasmus Lerdof en 1994; sin embargo la implementación principal
 de PHP es producida ahora por The PHP Group y sirve como el estándar de
 facto para PHP al no haber una especificación formal.
 PHP es publicado bajo la licencia PHP, la cual es considerada por la FSF
 como software libre.
\end_layout

\begin_layout Standard
PHP es un lenguaje interpretado de propósito general muy popular debido
 a la rapidez y facilidad con la que permite desarrollar aplicaciones.
 Fue diseñado originalmente para la creación de páginas Web dinámicas pero
 actualmente puede ser utilizado desde una interfaz de línea de comandos
 o desde una interfaz gráfica usando las bibliotecas Qt o GTK+.
 Cuenta con una comunidad de usuarios muy amplia y se encuentra disponible
 para su instalación en la mayoría de los servidores Web en casi cualquier
 plataforma.
 Se encuentra instalado en más de 20 millones de sitios Web y en un millón
 de servidores, aunque el número de sitios implementados en PHP ha declinado
 desde agosto de 2005.
\end_layout

\begin_layout Standard
Algunos de los puntos a destacar de PHP son: su facilidad de uso, su amplia
 documentación que incluye muchos ejemplos prácticos, que brinda soporte
 al paradigma de programación de orientación a objetos y que posee manejo
 de excepciones (aunque muchas de estas ventajas han aparecido recientemente
 en las últimas versiones de PHP).
\end_layout

\begin_layout Standard
Como mayor desventaja se presenta generalmente su característica de favorecer
 la creación de código desordenado y complejo de mantener.
 Esto tiene dos orígenes, por un lado se debe a que PHP brinda tantas facilidade
s en su uso que es muy popular entre usuarios programadores con poca formación
 técnica, y por otro lado la falta de una especificación formal resulta
 en algunos casos en una definición poco homogénea de las bibliotecas proporcion
adas por el lenguaje.
\end_layout

\begin_layout Subsection
PostgreSQL
\end_layout

\begin_layout Standard
PostgreSQL es un servidor de base de datos relacional con una trayectoria
 de más de 15 años de desarrollo activo.
 Se trata de un proyecto de código abierto liberado bajo la licencia BSD
 y desarrollado por una comunidad de desarrolladores y organizaciones comerciale
s denominada PGDG (PostgreSQL Global Development Group).
\end_layout

\begin_layout Standard
Comenzó con el proyecto Ingres en la Universidad de Berkeley.
 Este proyecto, liderado por Michael Stonebraker, fue uno de los primeros
 intentos de implementar un motor de base de datos relacional.
 Después de haber trabajado un largo tiempo en Ingres y de haber tenido
 una experiencia comercial con el mismo, Michael decidió volver a la Universidad
 para trabajar en un nuevo proyecto sobre la experiencia de Ingres.
 Dicho proyecto fue llamado Post-Ingres o simplemente Postgres.
\end_layout

\begin_layout Standard
PostgreSQL se encuentra disponible para una gran cantidad de sistemas operativos
 incluyendo Linux, UNIX (AIX, BSD, HP-UX, SGI IRIX, Mac OS X, Solaris, Tru64),
 y Windows.
 Una característica interesante que presenta PostgreSQL es su capacidad
 de acceso concurrente a la información, MVCC por sus siglas en inglés (Multi-Ve
rsion Concurrency Control).
 Mediante MVCC PostgreSQL permite el acceso de lectura a una tabla mientras
 que otro proceso realiza una operación de escritura sobre esa misma tabla.
 Esto se debe a que cada usuario obtiene una visión consistente de lo último
 a lo que se le hizo commit.
 Esta estrategia es superior al uso de bloqueos por tabla o por filas común
 en otras bases y elimina la necesidad del uso de bloqueos explícitos.
 
\end_layout

\begin_layout Standard
PostgreSQL realiza un gran énfasis en el seguimiento de los estándares ANSI/ISO
 SQL y su implementación de SQL se respeta muy fuertemente los estándares
 ANSI/ISO SQL-92 y 99.
\end_layout

\begin_layout Subsection
MySQL
\end_layout

\begin_layout Standard
MySQL es un sistema de gestión de base de datos relacional.
 MySQL AB
\begin_inset Foot
status open

\begin_layout Standard
Desde enero de 2008 una subsidiaria de Sun Microsystems.
\end_layout

\end_inset

 desarrolla MySQL como software libre en un esquema de licenciamiento dual.
 Por un lado se ofrece bajo la GNU GPL para cualquier uso compatible con
 esta licencia, pero las empresas que quieran incorporarlo a productos que
 no poseen código abierto deben comprar a la empresa una licencia específica
 que les permita este uso.
\end_layout

\begin_layout Standard
Se ha convertido en el sistema de gestión de base de datos relacional más
 popular, principalmente debido a su gran popularidad en Internet en el
 desarrollo de sitios Web dinámicos.
\end_layout

\begin_layout Standard
MySQL no posee el enfoque purista de PostgreSQL al momento de la implementación
 de un SQL que respete los estándares ANSI/ISO SQL.
 Si bien conforman en su mayoría los estándares '92 y '99 no es una meta
 principal del producto.
\end_layout

\end_body
\end_document
