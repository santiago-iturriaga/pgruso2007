#LyX 1.5.4 created this file. For more info see http://www.lyx.org/
\lyxformat 276
\begin_document
\begin_header
\textclass article
\language spanish
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\paperfontsize default
\spacing single
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 0
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language swedish
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Section
Cluster con acceso remoto
\end_layout

\begin_layout Standard
Para satisfacer los objetivos y requerimientos de un cluster de alto desempeño
 con acceso remoto planteados en el marco del proyecto se desarrolló el
 sistema Fenton.
 A continuación describiremos las tecnologías elegidas resultado de la etapa
 de relevamiento de tecnologías (en la sección 
\begin_inset LatexCommand vref
reference "sec:Relevamiento-de-tecnologías"

\end_inset

), la interfaz para acceso remoto al cluster, y todas las herramientas utilizada
s para el desarrollo y documentación a lo largo del proyecto.
 
\end_layout

\begin_layout Subsection
Tecnologías y herramientas elegidas
\end_layout

\begin_layout Standard
En esta sección se presentan y justifican las tecnologías seleccionadas
 para la implementación y documentación de los distintos componentes del
 sistema Fenton.
 Durante todo el proceso de desarrollo del sistema se  utilizaron exclusivamente
 herramientas de código libre (OSS).
\end_layout

\begin_layout Standard
Creemos que en la implementación del cluster radica el mayor riesgo para
 el proyecto.
 Un cluster de alto desempeño con un buen rendimiento y estabilidad brindarán
 una solida base sobre la cual construir el sistema.
 Luego de evaluar las tecnologías actuales disponibles para la implementación
 de cluster optamos por utilizar TORQUE como DRM y Maui como despachador,
 dejando abierta la posibilidad de anexar Gold para la contabilización de
 recursos.
 Luego de evaluar varios casos de estudio (en la sección 
\begin_inset LatexCommand vref
reference "sub:Torque-Casos-de-estudio"

\end_inset

) pudimos comprobar que TORQUE resulta muy adecuado para clusters de pequeño
 a mediano porte.
 Tanto TORQUE como Maui requieren pocos recursos de hardware para su ejecución,
 ventaja que resulta muy importante en un cluster de reducidas dimensiones
 como el que se desea utilizar.
\end_layout

\begin_layout Standard
TORQUE es un derivado de PBS (un DRM inicialmente desarrollado a mediados
 los años '90 para manejar recursos de computo aeroespacial en la NASA)
 por lo que cuenta con un código base muy estable y sólido.
 Esto ayuda a mitigar los riesgos presentados por tecnologías emergentes
 que ofrecen funcionalidades innovadoras pero que también resultan problemáticas
 en un proyecto de corta duración.
 Además otra ventaja que presenta TORQUE es su pequeño porte, resulta ser
 un producto relativamente pequeño facilitando su comprensión y por lo tanto
 su modificación y experimentación.
\end_layout

\begin_layout Standard
Si bien TORQUE brinda todas las funcionalidades necesarias para satisfacer
 los requerimientos del proyecto, también presenta ciertas carencias dentro
 de las cuales las más importantes son CPU harvesting y la migración de
 procesos.
 Dichas carencias no son un problema serio ya que el cluster que se utilizará
 cuenta con nodos homogéneos y dedicados, esto significa que los nodos del
 cluster tendrán capacidades de procesamiento muy similares y no serán compartid
os con otras aplicaciones externas al cluster (p.
 ej.: aplicaciones de escritorio).
\end_layout

\begin_layout Standard
Una vez seleccionado TORQUE como software para construir el cluster nos
 enfocamos en el componente de acceso remoto al sistema.
 Un requerimiento importante es brindar una interfaz de usuario simple y
 de facil acceso para usuarios no especializados, por esta razón y para
 evitar problemas con la posible heterogeneidad de los sistemas cliente
 decidimos brindar una interfaz de usuario Web para el acceso remoto al
 cluster.
\end_layout

\begin_layout Standard
Para el desarrollo del componente de acceso Web fue necesaria la definicion
 de varias herramientas: un servidor Web para alojar nuestra aplicación,
 un lenguaje server-side para implementar la lógica y una base de datos.
 Utilizar TORQUE y Maui para la implementación del cluster nos condiciona
 a trabajar sobre un sistema operativo Linux o Unix-BSD, por esta razón
 decidimos utilizar Apache como servidor Web.
 Apache es el servidor Web mas popular desde 1996, actualmente
\begin_inset Foot
status open

\begin_layout Standard
Encuesta realizada en Junio del 2008 por Netcraft.com.
 Netcraft fue fundada en 1995 y se especializa en el analisis de mercado
 de servidores y alojamiento web incluyendo detección de servidor web y
 sistema operativo
\end_layout

\end_inset

brinda servicio al 49.12% de los sitios de Internet y además se encuentra
 disponible para su instalación en cualquier sistema operativo de tipo Unix
 (*nix).
\end_layout

\begin_layout Standard
Teniendo en cuenta los conocimientos previos de los integrantes del grupo,
 así como la curva de aprendizaje de los diferentes lenguajes para desarrollar
 aplicaciones web, decidimos utilizar PHP como lenguaje de implenentación
 y Eclipse como IDE.
 PHP es un lenguaje intepretado de proposito general muy popular debido
 a la rapidez y facilidad con la que permite desarrollar aplicaciones, cuenta
 con una comunidad de usuarios muy amplia y se encuentra disponible para
 su instalación en la mayoría de los servidores web en casi cualquier plataforma.
\end_layout

\begin_layout Standard
Para el almacenamiento de datos se consideraron dos motores de base de datos
 relacional: PostgreSQL y MySQL.
 Finalmente elegimos trabajar con PostgreSQL, pero igualmente ambos cumplen
 con creces los requerimientos del proyecto.
 PostgreSQL es un motor de base de datos relacional de tipo empresarial,
 maduro, con buena integración con PHP y un muy buen soporte por parte de
 la comunidad.
 Si bien no es tan amigable ni tan popular como MySQL cuenta con una licencia
 de tipo BSD (Berkeley Software Distribution) mucho mas flexible y permisiva
 que la licencia utilizada por MySQL.
\end_layout

\begin_layout Standard
También fué necesario contar con una herramienta colaborativa que nos permitiera
  compartir y versionar tanto el código como los documentos.
 Para esto decidimos utilizar Google Code, un servicio de Google que provee
 un servicio de alojamiento de proyectos.
 Algunas de las funcionalidades que ofrece Google Code son: control de versiones
 utilizando  Subversion
\begin_inset Foot
status open

\begin_layout Standard
Subversion es un software de control de versiones diseñado específicamente
 para reemplazar al popular CVS.
\end_layout

\end_inset

, un manejador de incidencias, una wiki, etcétera.
\end_layout

\begin_layout Standard
Finalmente, para la documentación del proyecto utilizamos LyX.
 LyX es un programa gráfico  que permite la edición de texto usando LaTeX,
 por lo que hereda todas las capacidades de LaTeX (notación científica,
 edición de ecuaciones, creación de índices, etcétera) y por supuesto mantiene
 el enfoque WYSIWYM de LaTeX.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Standard
Mencionar OpenSource como requerimiento!!!
\end_layout

\begin_layout Standard
sistema operativo tipo unix (http://en.wikipedia.org/wiki/Unix-like) (*nix)
\end_layout

\begin_layout Standard
lenguaje server-side (http://en.wikipedia.org/wiki/Server-side_scripting)
\end_layout

\begin_layout Standard
BSD (Berkeley Software Distribution)Subversion http://subversion.tigris.org/
\end_layout

\begin_layout Standard
WYSIWYM
\end_layout

\begin_layout Standard
LaTeX
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Desarrollo de la solución
\end_layout

\begin_layout Standard
El motor de base de datos en principio podía ser MySQL o PostgreSQL y la
 decisión entre uno de los dos no la podíamos tomar hasta tiempo después
 de iniciada la etapa de implementación, por lo tanto se pensó desde un
 principio en un módulo de abstracción al motor de base de datos que ejecutara
 las operaciones básicas (abrir la conexión, ejecutar una consulta, obtener
 el resultado) e implementarlo tanto para MySQL como para PostgreSQL.
 Este requerimiento redundó en una ventaja para el producto: si fuera necesario
 instalarlo sobre otro motor de condiciones similares, en principio solo
 sería necesario reimplementar el módulo y repetir la etapa de testeo.
\end_layout

\begin_layout Standard
La apariencia del sitio también podía variar durante la implementación,
 por lo tanto además de separar la lógica de la aplicación de la capa de
 presentación, esta última se dividió en archivos .php que reciben los pedidos
 del usuario y actúan en consecuencia, separados de los archivos .html y
 .css orientados a la forma en que estos resultados se muestran.
 Para esto utilizamos plantillas que son cargadas en cada php para luego
 ser desplegadas en pantalla.
 En definitiva obtuvimos una versión moderada del patrón model view controller.
 Si en algún momento se deseara rediseñar el sitio manteniendo el funcionamiento
 del mismo, la mayor parte se puede cambiar desde la hoja de estilos y el
 resto desde las plantillas en formato .html.
\end_layout

\begin_layout Paragraph*
\begin_inset Graphics
	filename diagrama.gif
	scale 25

\end_inset


\end_layout

\begin_layout Standard
La aplicación permite un manejo de usuarios con perfiles diferenciados.
 Inicialmente podemos separar a los usuarios entre administradores y clientes
 finales, pero es posible ejercer diferencias más sutiles entre ellos.
 Para esto se diseñó un sistema de grupos de usuarios con funcionalidades
 asociadas, de esta manera podemos permitir a algunos usuarios acceder a
 algunas partes de la administración sin permitirles (por ejemplo) administrar
 los usuarios.
 En definitiva, cada usuario puede pertenecer a uno o más grupos, y estos
 a su vez pueden tener funcionalidades y trabajos asociados.
 Un usuario determinado puede hacer uso de una funcionalidad dada si pertenece
 a algún grupo que se lo permita, mientras que puede acceder a un trabajo
 determinado si pertenece a algún grupo con acceso al mismo.
\end_layout

\begin_layout Standard
La interfaz de usuario varía notablemente según el perfil, si bien ambos
 usuarios tienen cierto conocimiento sobre el uso de aplicaciones, el cliente
 final no tiene por que estar interiorizado con el funcionamiento del cluster,
 por lo tanto se le presenta el sistema como un todo.
 Por otro lado el administrador podrá desde su propia interfaz conocer el
 estado de los nodos del cluster e interactuar con ellos para solucionar
 posibles problemas o mejorar su performance.
\end_layout

\begin_layout Standard
El usuario administrador tendrá a su cargo la tarea de mantener los usuarios
 y grupos del sistema así como el acceso de los mismos a los distintos trabajos.
 Dado que nos encontramos en un ambiente multiusuario, la aplicación permite
 administrar las reservas del clúster, para organizar la utilización de
 recursos por varios usuarios de forma simultánea.
 Cada trabajo creado tendrá asociado un conjunto de recursos disponibles
 que determinarán el posterior funcionamiento de las ejecuciones de los
 clientes.
 Para esta implementación nos restringimos al uso de disco, tiempo máximo
 de ejecución y cantidad de nodos disponibles a la vez, pero es posible
 agregar recursos a restringir (memoria, ciclos de procesador, etc.).
\end_layout

\begin_layout Standard
El usuario final tendrá la posibilidad de subir su proyecto al cluster,
 compilarlo, ejecutarlo y ver la salida a pantalla en tiempo real.
 Dados los extensos tiempos de ejecución de los programas que se corren
 en clusters de estas características, el usuario puede abandonar el sitio
 para luego volver en otro momento.
 Si el programa sigue en ejecución puede ver la salida a pantalla (nuevamente
 en tiempo real) junto con las salidas anteriores de la misma ejecución.
 Para los trabajos terminados existe la posibilidad de ver la salida en
 pantalla o descargarla en un archivo.
\end_layout

\begin_layout Subsection
Testeo de la solución
\end_layout

\begin_layout Standard
Una de las actividades de este proceso fue el testeo de las tecnologías
 propuestas y el testeo de la interfaz web desarrollada.
 Los objetivos de esta etapa son la verificación y validación de los requerimien
tos funcionales establecidos en etapas mas tempranas y que fueran objetivos
 del proyecto.
\end_layout

\begin_layout Standard
Durante el proceso de testing se aplicaron dos tipos de test.
 Se realizó un test funcional apoyado o complementado con un test exploratorio.
 El testing funcional verifica el cumplimiento de los requerimientos funcionales
 contra los casos de test, en un entorno que emula un ambiente de producción
 del sistema.
 El objetivo de este test es verificar si el comportamiento observado del
 software a prueba coincide o no con sus especificaciones.
 
\end_layout

\begin_layout Standard
El test exploratorio es un proceso simultáneo de exploración y aprendizaje
 del producto, diseño y ejecución de pruebas.
 La estrategia en este caso fue recorrer las funcionalidades de la interfaz
 en busca de defectos de diseño, de programación, de funcionamiento, etc.
\end_layout

\begin_layout Standard
Durante el test exploratorio se generaron un serie de casos de test ques
 apuntan a cubrir los requerimientos funcionales principales del sistema.
 Estos casos de test se incluyeron en la Guía de Test (ver página 
\begin_inset LatexCommand pageref
reference "sub:Guía-de-testeo"

\end_inset

), pretendiendo guiar el testeo en posteriores ocasiones.
 El mismo incluye casos de test y escenarios de pruebas que integran los
 casos de test, así como una descripción del proceso ejecutado para esta
 oportunidad.
\end_layout

\begin_layout Standard
Las herramientas utilizadas en el testing fueron la guía de test y las funcional
idades provistas por el Google Code como son registro Issues y Wikis.
\end_layout

\end_body
\end_document
